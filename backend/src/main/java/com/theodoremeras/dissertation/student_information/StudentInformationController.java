package com.theodoremeras.dissertation.student_information;

import com.theodoremeras.dissertation.user.UserEntity;
import com.theodoremeras.dissertation.user.UserService;
import jakarta.validation.Valid;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.*;

import java.util.*;
import java.util.stream.Collectors;

@RestController
public class StudentInformationController {

    private final StudentInformationService studentInformationService;

    private final UserService userService;

    private final StudentInformationMapper studentInformationMapper;

    private final JwtDecoder jwtDecoder;

    public StudentInformationController(
            StudentInformationService studentInformationService,
            UserService userService, StudentInformationMapper studentInformationMapper, JwtDecoder jwtDecoder
    ) {
        this.studentInformationService = studentInformationService;
        this.userService = userService;
        this.studentInformationMapper = studentInformationMapper;
        this.jwtDecoder = jwtDecoder;
    }

    @PostMapping(path = "/student-information")
    public ResponseEntity<StudentInformationDto> createStudentInformation(
            @RequestBody @Valid StudentInformationDto studentInformationDto
    ) {
        // Id will be autogenerated
        studentInformationDto.setId(null);

        StudentInformationEntity studentInformationEntity = studentInformationMapper.mapFromDto(studentInformationDto);

        // Verify that the specified student exists
        Optional<UserEntity> student = userService.findOneById(studentInformationEntity.getStudent().getId());
        if (student.isPresent())
            studentInformationEntity.setStudent(student.get());
        else
            return new ResponseEntity<>(HttpStatus.NOT_FOUND);

        StudentInformationEntity savedStudentInformationEntity =
                studentInformationService.save(studentInformationEntity);

        return new ResponseEntity<>(
                studentInformationMapper.mapToDto(savedStudentInformationEntity),
                HttpStatus.CREATED
        );
    }

    @GetMapping(path = "/student-information")
    public ResponseEntity<List<StudentInformationDto>> getAllStudentInformation(
            @RequestParam(value = "studentId", required = false) Integer studentId,
            @RequestHeader(name = "Authorization") String token
    ) {
        // Extract the user's id and role from the token
        Jwt jwt = jwtDecoder.decode(token.split(" ")[1]);
        Long userId = jwt.getClaim("userId");
        String userRole = jwt.getClaim("roles");

        List<StudentInformationEntity> studentInformationEntities;

        // Fetch all student information
        if (studentId == null) {
            // Students are not allowed to fetch all student information
            if (userRole.equals("Student"))
                return new ResponseEntity<>(HttpStatus.FORBIDDEN);

            studentInformationEntities = studentInformationService.findAll();
        }
        // Fetch only the information of the specified student
        else {
            // Students are not allowed to view the information of other students
            if (userRole.equals("Student") && !studentId.equals(userId.intValue()))
                return new ResponseEntity<>(HttpStatus.FORBIDDEN);

            Optional<StudentInformationEntity> foundStudentInformation =
                    studentInformationService.findOneByStudentId(studentId);
            studentInformationEntities = foundStudentInformation
                    .map(studentInformationEntity -> new ArrayList<>(List.of(studentInformationEntity)))
                    .orElseGet(ArrayList::new);
        }

        return new ResponseEntity<>(studentInformationEntities.stream()
                .map(studentInformationMapper::mapToDto)
                .collect(Collectors.toList()), HttpStatus.OK);
    }

    @PatchMapping(path = "/student-information/{id}")
    public ResponseEntity<StudentInformationDto> partialUpdateStudentInformation(
            @PathVariable("id") Integer id, @RequestBody StudentInformationDto studentInformationDto,
            @RequestHeader(name = "Authorization") String token
    ) {
        // Extract the user's id and role from the token
        Jwt jwt = jwtDecoder.decode(token.split(" ")[1]);
        Long userId = jwt.getClaim("userId");
        String userRole = jwt.getClaim("roles");

        if (!studentInformationService.exists(id))
            return new ResponseEntity<>(HttpStatus.NOT_FOUND);

        // Students are only allowed to edit their own information
        if (userRole.equals("Student") &&
                studentInformationService.findOneById(id).get().getStudent().getId() != userId.intValue()) {
            return new ResponseEntity<>(HttpStatus.FORBIDDEN);
        }


        studentInformationDto.setId(id);
        StudentInformationEntity studentInformationEntity = studentInformationMapper.mapFromDto(studentInformationDto);
        StudentInformationEntity updatedStudentInformationEntity =
                studentInformationService.partialUpdate(id, studentInformationEntity);
        return new ResponseEntity<>(
                studentInformationMapper.mapToDto(updatedStudentInformationEntity),
                HttpStatus.OK
        );
    }

    @DeleteMapping(path = "/student-information/{id}")
    public ResponseEntity<String> deleteStudentInformation(@PathVariable("id") Integer id) {
        studentInformationService.delete(id);
        return new ResponseEntity<>(HttpStatus.NO_CONTENT);
    }

    @ResponseStatus(HttpStatus.BAD_REQUEST)
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public Map<String, String> handleValidationExceptions(
            MethodArgumentNotValidException ex) {
        Map<String, String> errors = new HashMap<>();
        ex.getBindingResult().getAllErrors().forEach((error) -> {
            String fieldName = ((FieldError) error).getField();
            String errorMessage = error.getDefaultMessage();
            errors.put(fieldName, errorMessage);
        });
        return errors;
    }

}
